def solution(begin, end):
    
    # 먼저 깔려있던 블록을 빼내고 뒤의 숫자 블록이 설치되는 것에 초점을 맞춰야한다
    # 그리고 숫자 첫 블록은 1의 배수는 즉, 숫자 자신의 값에는 설치되지 않는다. (소수 경우 무조건 1, 1은 0)
    # 한 자리에 여러 블록(약수들)이 들어갈 수 있어도 최종적으로는 가장 큰 값이 들어감 
    # = 해당 블록의 index를 나눌 수 있는 가장 큰 약수 값이 최종 값
    # 하지만 블록 길이는 10억, 블록 숫자는 천만의 제한이 있으므로 천만 초과의 수들은 천만 이하의 가장 큰 약수를 구해야한다 
    
    # 값 정의할 배열 정의
    block = [] 
    
    for i in range(begin, end+1):
        # 소수일 경우를 위한 기본세팅 : 1이면 0, 나머지는 1
        block_num = 0 if i == 1 else 1;  
        
        # 소수가 아닌 경우 약수 구하기 
        for j in range(2, int(i**0.5)+1): # 효율성 상승 위해 제곱근 까지만 
            if i%j == 0: # 약수인 경우
                # 처음 만나는 약수로 나눈 목이 가장 큰 최대약수가 되는데 이때 이 숫자가 천만이 안넘으면 대입
                if i//j <= 10000000: 
                    block_num = i//j
                    break
        
        # 블록 설치
        block.append(block_num)

    return block

        